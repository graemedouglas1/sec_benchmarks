---

inspec_rules:
  "1.1.1":
    title: '1.1.1 | Ensure a separate partition for containers has been created - manual'
    section: 'Linux Hosts Specific Configuration'
    description: |
        All Docker containers and their data and metadata is stored under              /var/lib/docker
         directory. By default,              /var/lib/docker
         should be mounted under either the              /
         or              /var
         partitions dependent on how the Linux operating system in use is configured.
    remediation: |
        For new installations,  you should create a separate partition for the                  /var/lib/docker
         mount point. For systems which have already been installed, you should use the Logical Volume Manager (LVM) within
        Linux to create a new partition.               Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_1.1.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "1.1.2":
    title: '1.1.2 | Ensure only trusted users are allowed to control Docker daemon - manual'
    section: 'Linux Hosts Specific Configuration'
    description: |
        The Docker daemon currently requires access to the Docker socket which is, by default, owned by the user
        root
         and the group              docker
        .
    remediation: |
        You should remove any untrusted users from the                  docker
         group. Additionally, you should not create a mapping of sensitive directories from the host to container volumes.
        Impact: Provided the proceeding instructions are implemented, rights to build and execute containers as normal user
        would be restricted.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_1.1.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "1.1.3":
    title: '1.1.3 | Ensure auditing is configured for the Docker daemon'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit all Docker daemon activities.
    remediation: |
        You should add rules for the Docker daemon. For example:
        Add the line below to the                  /etc/audit/rules.d/audit.rules
         file:               -w /usr/bin/dockerd -k docker
         Then, restart the audit daemon using the following command systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_1.1.3', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "1.1.4":
    title: '1.1.4 | Ensure auditing is configured for Docker files and directories - runcontainerd - manual'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /run/containerd
        .
    remediation: |
        You should add a rule for the                  /run/containerd
         directory.               For example,
        Add the line as below to the                  /etc/audit/rules.d/audit.rules
         file:               -a exit,always -F path=/run/containerd -F perm=war -k docker
         Then, restart the audit daemon using the following command systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_1.1.4', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "1.1.5":
    title: '1.1.5 | Ensure auditing is configured for Docker files and directories - varlibdocker'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /var/lib/docker
        .
    remediation: |
        You should add a rule for the                  /var/lib/docker
         directory.
        Adding exclusions for /var/lib/docker/overlay2 & /var/lib/docker/volumes reduces the audit messages to a more manageable
        level.               For example,
        Add the line as below to the                  /etc/audit/rules.d/audit.rules
         file:
        -a exit,always -F path=/var/lib/docker -F perm=war -k docker
        -a exit,never -F dir=/var/lib/docker/volumes
        -a exit,never -F dir=/var/lib/docker/overlay2
                       or for systems with namespace-remapping enabled
        -a exit,always -F path=/var/lib/docker -F perm=war -k docker
        -a exit,never -F dir=/var/lib/docker/165536.165536/volumes
        -a exit,never -F dir=/var/lib/docker/165536.165536/overlay2
                       Then, restart the audit daemon using the following command systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_1.1.5', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "1.1.6":
    title: '1.1.6 | Ensure auditing is configured for Docker files and directories - etcdocker'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /etc/docker
        .
    remediation: |
        You should add a rule for the                  /etc/docker
         directory.               For example:
        Add the line below to the                  /etc/audit/rules.d/audit.rules
         file:               -w /etc/docker -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_1.1.6', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "1.1.7":
    title: '1.1.7 | Ensure auditing is configured for Docker files and directories - docker.service'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit the              docker.service
         if applicable.
    remediation: |
        If the file exists, a rule for it should be added. For example:
        Add the line as below in                  /etc/audit/rules.d/audit.rules
         file:               -w /usr/lib/systemd/system/docker.service -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.7', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.8":
    title: '1.1.8 | Ensure auditing is configured for Docker files and directories - containerd.sock'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              containerd.sock
        , if applicable.
    remediation: |
        If the file exists, you should add a rule for it. For example:
        Add the line below to the                  /etc/audit/rules.d/audit.rules
         file:               -w /run/containerd/containerd.sock -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.8', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.9":
    title: '1.1.9 | Ensure auditing is configured for Docker files and directories - docker.sock'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              docker.sock
        , if applicable.
    remediation: |
        If the file exists, you should add a rule for it. For example:
        Add the line below to the                  /etc/audit/rules.d/audit.rules
         file:               -w /var/run/docker.sock -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.9', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.10":
    title: '1.1.10 | Ensure auditing is configured for Docker files and directories - etcdefaultdocker'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /etc/default/docker
        , if applicable.
    remediation: |
        You should add a rule for the                  /etc/default/docker
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /etc/default/docker -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.10', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.11":
    title: '1.1.11 | Ensure auditing is configured for Docker files and directories - etcdockerdaemon.json'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /etc/docker/daemon.json
        , if applicable.
    remediation: |
        You should add a rule for the                  /etc/docker/daemon.json
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /etc/docker/daemon.json -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.11', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.12":
    title: '1.1.12 | Ensure auditing is configured for Docker files and directories - etccontainerdconfig.toml'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /etc/containerd/config.toml
         if applicable
    remediation: |
        You should add a rule for                  /etc/containerd/config.toml
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /etc/containerd/config.toml -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.12', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.13":
    title: '1.1.13 | Ensure auditing is configured for Docker files and directories - etcsysconfigdocker'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /etc/sysconfig/docker
         if applicable
    remediation: |
        You should add a rule for                  /etc/sysconfig/docker
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /etc/sysconfig/docker -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.13', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.14":
    title: '1.1.14 | Ensure auditing is configured for Docker files and directories - usrbincontainerd'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /usr/bin/containerd
         if applicable.
    remediation: |
        You should add a rule for the                  /usr/bin/containerd
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /usr/bin/containerd -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.14', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.15":
    title: '1.1.15 | Ensure auditing is configured for Docker files and directories - usrbincontainerd-shim'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /usr/bin/containerdshim
         if applicable.
    remediation: |
        You should add a rule for the                  /usr/bin/containerd-shim
         file.               For example:
        Add the line below to the                  /etc/audit/rules.d/audit.rules
         file:               -w /usr/bin/containerd-shim -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.15', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.16":
    title: '1.1.16 | Ensure auditing is configured for Docker files and directories - usrbincontainerd-shim-runc-v1'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /usr/bin/containerdshimruncv1
         if applicable.
    remediation: |
        You should add a rule for the                  /usr/bin/containerd-shim-runc-v1
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /usr/bin/containerd-shim-runc-v1 -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_1.1.16', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "1.1.17":
    title: '1.1.17 | Ensure auditing is configured for Docker files and directories - usrbincontainerd-shim-runc-v2'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /usr/bin/containerdshimruncv2
         if applicable.
    remediation: |
        You should add a rule for the                  /usr/bin/containerd-shim-runc-v2
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /usr/bin/containerd-shim-runc-v2 -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.17', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.1.18":
    title: '1.1.18 | Ensure auditing is configured for Docker files and directories - usrbinrunc'
    section: 'Linux Hosts Specific Configuration'
    description: |
        Audit              /usr/bin/runc
         if applicable
    remediation: |
        You should add a rule for                  /usr/bin/runc
         file.               For example:
        Add the line below to the                  /etc/audit/audit.rules
         file:               -w /usr/bin/runc -k docker
         Then restart the audit daemon. For example: systemctl restart auditd
         Impact: Auditing can generate large log files. You should ensure that these are rotated and archived periodically. A
        separate partition should also be created for audit logs to avoid filling up any other critical partition.
    type: Undefined
    impact: '1.0'
    tags: ['level2', 'rule_1.1.18', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'
            - name: Undefined
              rule: 'Undefined'

  "1.2.1":
    title: '1.2.1 | Ensure the container host has been Hardened - manual'
    section: 'General Configuration'
    description: |
        A container host is able to run one or more containers. It is of utmost importance to harden the host to mitigate host
        security misconfiguration.
    remediation: |
        You may consider various CIS Security Benchmarks for your container host. If you have other security guidelines or
        regulatory requirements to adhere to, please follow them as suitable in your environment. Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_1.2.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "1.2.2":
    title: '1.2.2 | Ensure that the version of Docker is up to date - manual'
    section: 'General Configuration'
    description: |
        Frequent releases for Docker are issued which address security vulnerabilities, resolve product bugs and bring in new
        functionality. You should keep a tab on these product updates and upgrade as frequently as possible in line with the
        general IT security policy of your organization.
    remediation: |
        You should monitor versions of Docker releases and make sure your software is updated as required. Impact: You should
        perform a risk assessment regarding Docker version updates and review how they may impact your operations.  You should
        be aware that third-party products that use Docker may require older major versions of Docker to be supported, and this
        should be reviewed in line with the general IT security policy of your organization, particularly where security
        vulnerabilities in older versions have been publicly disclosed.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_1.2.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.1":
    title: '2.1 | Run the Docker daemon as a non-root user if possible - manual'
    section: 'Docker daemon configuration'
    description: |
        Rootless mode executes the Docker daemon and containers inside a user namespace, with both the daemon and the container
        are running without root privileges.
    remediation: |
        Follow the current Docker documentation on how to install the Docker daemon as a non-root user. Impact: There are
        multiple prerequisites depending on which distribution that is in use, and also known limitations regarding networking
        and resource limitation. Running in rootless mode also changes the location of any configuration files in use, including
        all containers using the daemon.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.2":
    title: '2.2 | Ensure network traffic is restricted between containers on the default bridge - manual'
    section: 'Docker daemon configuration'
    description: |
        By default, all network traffic is allowed between containers on the same host on the default network bridge. If not
        desired, restrict all intercontainer communication. Link specific containers together that require communication.
        Alternatively, you can create custom network and only join containers that need to communicate to that custom network.
    remediation: |
        Edit the Docker daemon configuration file to ensure that icc is disabled. It should include the following setting "icc":
        false

        Alernatively, run the docker daemon directly and pass                --icc=false
         as an argument.             For Example, dockerd --icc=false

        Alternatively, you can follow the Docker documentation and create a custom network and only join containers that need to
        communicate to that custom network. The                --icc
         parameter only applies to the default docker bridge, if custom networks are used then the approach of segmenting
        networks should be adopted instead.
        In order for this control to be fully effective, all containers connected to the                docker0
         bridge should drop the                NET_RAW
         capability, otherwise a compromised container could use raw ethernet packets to communicate with other containers
        despite this restriction.             Impact: Inter-container communication would be disabled on the default network
        bridge. If any communication between containers on the same host is desired, then it needs to be explicitly defined
        using container linking or alternatively custom networks have to be defined.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.3":
    title: '2.3 | Ensure the logging level is set to info - manual'
    section: 'Docker daemon configuration'
    description: |
        Set Docker daemon log level to            info
        .
    remediation: |
        Ensure that the Docker daemon configuration file has the following configuration included "log-level": "info"
         Alternatively, run the Docker daemon as below: dockerd --log-level="info"
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.3', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.4":
    title: '2.4 | Ensure Docker is allowed to make changes to iptables - manual'
    section: 'Docker daemon configuration'
    description: |
        The iptables firewall is used to set up, maintain, and inspect the tables of IP packet filter rules within the Linux
        kernel.  The Docker daemon should be allowed to make changes to the            iptables
         ruleset.
    remediation: |
        Do not run the Docker daemon with                --iptables=false
         parameter. For example, do not start the Docker daemon as below:             dockerd --iptables=false
         Impact: The Docker daemon service requires iptables rules to be enabled before it starts.  Any restarts of iptables
        during Docker daemon operation may result in losing Docker created rules.  Adding iptables-persistent to your iptables
        install can assist with mitigation of this impact.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.4', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.5":
    title: '2.5 | Ensure insecure registries are not used - manual'
    section: 'Docker daemon configuration'
    description: |
        Docker considers a private registry either secure or insecure. By default, registries are considered secure.
    remediation: |
        You should ensure that no insecure registries are in use. Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.5', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.6":
    title: '2.6 | Ensure aufs storage driver is not used - manual'
    section: 'Docker daemon configuration'
    description: |
        Do not use            aufs
         as the storage driver for your Docker instance.
    remediation: |
        Do not explicitly use                aufs
         as storage driver.             For example, do not start Docker daemon as below: dockerd --storage-driver aufs
         Impact: aufs
         is the only storage driver that allows containers to share executable and shared library memory. It might be useful if
        you are running thousands of containers with the same program or libraries, however its use should be reviewed in line
        with your organization's security policy.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.6', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.7":
    title: '2.7 | Ensure TLS authentication for Docker daemon is configured - manual'
    section: 'Docker daemon configuration'
    description: |
        It is possible to make the Docker daemon available remotely over a TCP port. If this is required, you should ensure that
        TLS authentication is configured in order to restrict access to the Docker daemon via IP address and port.
    remediation: |
        Follow the steps mentioned in the Docker documentation or other references. Impact: You would need to manage and guard
        certificates and keys for the Docker daemon and Docker clients.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.7', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.8":
    title: '2.8 | Ensure the default ulimit is configured appropriately - manual'
    section: 'Docker daemon configuration'
    description: |
        Set the default ulimit options as appropriate in your environment.
    remediation: |
        Run Docker in daemon mode and pass                --default-ulimit
         as argument with respective ulimits as appropriate in your environment and in line with your security policy.
        For Example, dockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200
         Impact: If ulimits are set incorrectly this could cause issues with system resources, possibly causing a denial of
        service condition.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.8', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.9":
    title: '2.9 | Enable user namespace support - manual'
    section: 'Docker daemon configuration'
    description: |
        You should enable user namespace support in Docker daemon to utilize container user to host user remapping. This
        recommendation is beneficial where the containers you are using do not have an explicit container user defined in the
        container image. If the container images that you are using have a predefined nonroot user, this recommendation may be
        skipped as this feature is still in its infancy, and might result in unpredictable issues or difficulty in
        configuration.
    remediation: |
        Please consult the Docker documentation for various ways in which this can be configured depending upon your
        requirements. Your steps might also vary based on platform - For example, on Red Hat, sub-UIDs and sub-GIDs mapping
        creation do not work automatically. You might have to create your own mapping. The high-level steps are as below: Step
        1:
         Ensure that the files                /etc/subuid
         and                /etc/subgid
         exist.             touch /etc/subuid /etc/subgid
         Step 2:
         Start the docker daemon with                --userns-remap
         flag             dockerd --userns-remap=default
         Impact: User namespace remapping is incompatible with a number of Docker features and also currently breaks some of its
        functionalities. Reference the Docker documentation and included links for details.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_2.9', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.10":
    title: '2.10 | Ensure the default cgroup usage has been confirmed - manual'
    section: 'Docker daemon configuration'
    description: |
        The            cgroupparent
         option allows you to set the default cgroup parent to use for all containers. If there is no specific usage requirement
        for this, the setting should be left at its default.
    remediation: |
        The default setting is in line with good security practice and can be left in situ. If you wish to specifically set a
        non-default cgroup, pass the                --cgroup-parent
         parameter to the Docker daemon when starting it.             For example, dockerd --cgroup-parent=/foobar
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_2.10', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.11":
    title: '2.11 | Ensure base device size is not changed until needed - manual'
    section: 'Docker daemon configuration'
    description: |
        Under certain circumstances, you might need containers larger than 10G. Where this applies you should carefully choose
        the base device size.
    remediation: |
        Do not set                --storage-opt dm.basesize
         until needed.             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_2.11', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.12":
    title: '2.12 | Ensure that authorization for Docker client commands is enabled - manual'
    section: 'Docker daemon configuration'
    description: |
        You should use native Docker authorization plugins or a third party authorization mechanism with the Docker daemon to
        manage access to Docker client commands.
    remediation: |
        Step 1
        : Install/Create an authorization plugin.             Step 2
        : Configure the authorization policy as desired.             Step 3
        : Start the docker daemon as below:             dockerd --authorization-plugin=<PLUGIN_ID>
         Impact: Each Docker command needs to pass through the authorization plugin mechanism. This may have a performance
        impact. It may be possible to use alternative mechanisms that do not have this performance hit.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_2.12', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.13":
    title: '2.13 | Ensure centralized and remote logging is configured - manual'
    section: 'Docker daemon configuration'
    description: |
        Docker supports various logging mechanisms. A preferable method for storing logs is one that supports centralized and
        remote management.
    remediation: |
        Step 1
        : Set up the desired log driver following its documentation.             Step 2
        : Start the docker daemon using that logging driver.             For example: dockerd --log-driver=syslog --log-opt
        syslog-address=tcp://192.xxx.xxx.xxx
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_2.13', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.14":
    title: '2.14 | Ensure containers are restricted from acquiring new privileges - manual'
    section: 'Docker daemon configuration'
    description: |
        By default you should restrict containers from acquiring additional privileges via suid or sgid.
    remediation: |
        You should run the Docker daemon as below: dockerd --no-new-privileges
         Impact: no_new_priv
         prevents LSMs such as SELinux from escalating the privileges of individual containers.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.14', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.15":
    title: '2.15 | Ensure live restore is enabled - manual'
    section: 'Docker daemon configuration'
    description: |
        The            liverestore
         option enables full support of daemonless containers within Docker. It ensures that Docker does not stop containers on
        shutdown or restore and that it properly reconnects to the container when restarted.
    remediation: |
        Run Docker in daemon mode and pass                --live-restore
         to it as an argument.             For Example, dockerd --live-restore
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.15', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.16":
    title: '2.16 | Ensure Userland Proxy is Disabled - manual'
    section: 'Docker daemon configuration'
    description: |
        The Docker daemon starts a userland proxy service for port forwarding whenever a port is exposed. Where hairpin NAT is
        available, this service is generally superfluous to requirements and can be disabled.
    remediation: |
        You should run the Docker daemon as below: dockerd --userland-proxy=false
         Impact: Some systems with older Linux kernels may not be able to support hairpin NAT and therefore require the userland
        proxy service. Also, some networking setups can be impacted by the removal of the userland proxy.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.16', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.17":
    title: '2.17 | Ensure that a daemon-wide custom seccomp profile is applied if appropriate - manual'
    section: 'Docker daemon configuration'
    description: |
        You can choose to apply a custom seccomp profile at a daemonwide level if needed with this overriding Dockers default
        seccomp profile.
    remediation: |
        By default, Docker's default seccomp profile is applied. If this is adequate for your environment, no action is
        necessary. Alternatively, if you choose to apply your own seccomp profile, use the                --seccomp-profile
         flag at daemon start or put it in the daemon runtime parameters file.             dockerd --seccomp-profile
        </path/to/seccomp/profile>
         Impact: A misconfigured seccomp profile could possibly interrupt your container environment. Docker-default blocked
        calls have been carefully scrutinized and address some critical vulnerabilities/issues within container environments
        (for example, kernel key ring calls). You should therefore exercise extreme care if you choose to override the default
        settings.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_2.17', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "2.18":
    title: '2.18 | Ensure that experimental features are not implemented in production - manual'
    section: 'Docker daemon configuration'
    description: |
        Experimental features should not be enabled in production.
    remediation: |
        You should not pass                --experimental
         as a runtime parameter to the Docker daemon on production systems.             Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_2.18', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.1":
    title: '3.1 | Ensure that the docker.service file ownership is set to rootroot'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            docker.service
         file ownership and group ownership are correctly set to            root
        .
    remediation: |
        Step 1
        : Find out the file location:             systemctl show -p FragmentPath docker.service
         Step 2
        : If the file does not exist, this recommendation is not applicable. If the file does exist, you should execute the
        command below, including the correct file path, in order to set the ownership and group ownership for the file to
        root
        .             For example, chown root:root /usr/lib/systemd/system/docker.service
         Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.1', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "3.2":
    title: '3.2 | Ensure that docker.service file permissions are appropriately set'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            docker.service
         file permissions are either set to            644
         or to a more restrictive value.
    remediation: |
        Step 1
        : Find out the file location:             systemctl show -p FragmentPath docker.service
         Step 2
        : If the file does not exist, this recommendation is not applicable. If the file exists, execute the command below
        including the correct file path to set the file permissions to                644
        .             For example, chmod 644 /usr/lib/systemd/system/docker.service
         Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.2', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "3.3":
    title: '3.3 | Ensure that docker.socket file ownership is set to rootroot'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            docker.socket
         file ownership and group ownership are correctly set to            root
        .
    remediation: |
        Step 1
        : Find out the file location:             systemctl show -p FragmentPath docker.socket
         Step 2
        : If the file does not exist, this recommendation is not applicable. If the file exists, execute the command below,
        including the correct file path to set the ownership and group ownership for the file to                root
        .             For example, chown root:root /usr/lib/systemd/system/docker.socket
         Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.3', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "3.4":
    title: '3.4 | Ensure that docker.socket file permissions are set to 644 or more restrictive'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the file permissions on the            docker.socket
         file are correctly set to            644
         or more restrictively.
    remediation: |
        Step 1
        : Find out the file location:             systemctl show -p FragmentPath docker.socket
         Step 2
        : If the file does not exist, this recommendation is not applicable. If the file does exist, you should execute the
        command below, including the correct file path to set the file permissions to                644
        .             For example, chmod 644 /usr/lib/systemd/system/docker.socket
         Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.4', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "3.5":
    title: '3.5 | Ensure that the etcdocker directory ownership is set to rootroot'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            /etc/docker
         directory ownership and group ownership is correctly set to            root
        .
    remediation: |
        To resolve this issue you should run the following command: chown root:root /etc/docker

        This sets the ownership and group ownership for the directory to                root
        .             Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.5', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "3.6":
    title: '3.6 | Ensure that etcdocker directory permissions are set to 755 or more restrictively'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            /etc/docker
         directory permissions are correctly set to            755
         or more restrictively.
    remediation: |
        You should run the following command: chmod 755 /etc/docker

        This sets the permissions for the directory to                755
        .             Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.6', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "3.7":
    title: '3.7 | Ensure that registry certificate file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that all the registry certificate files usually found under
        /etc/docker/certs.d/registryname
         directory are individually owned and group owned by            root
        .
    remediation: |
        The following command could be executed: chown root:root /etc/docker/certs.d/<registry-name>/*

        This would set the individual ownership and group ownership for the registry certificate files to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.7', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.8":
    title: '3.8 | Ensure that registry certificate file permissions are set to 444 or more restrictively - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that all the registry certificate files usually found under
        /etc/docker/certs.d/registryname
         directory have permissions of            444
         or are set more restrictively.         Note that, by default, this directory might not exist if no registry certificate
        files are in place.
    remediation: |
        You should execute the following command: find /etc/docker/certs.d/ -type f -exec chmod 0444 {} \;

        This would set the permissions for the registry certificate files to                444
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.8', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.9":
    title: '3.9 | Ensure that TLS CA certificate file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the TLS CA certificate file the file that is passed along with the            tlscacert
         parameter is individually owned and group owned by            root
        .
    remediation: |
        You should execute the following command: chown root:root <path to TLS CA certificate file>

        This sets the individual ownership and group ownership for the TLS CA certificate file to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.9', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.10":
    title: '3.10 | Ensure that TLS CA certificate file permissions are set to 444 or more restrictively - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the TLS CA certificate file the file that is passed along with the            tlscacert
         parameter has permissions of            444
         or is set more restrictively.
    remediation: |
        You should execute the following command: chmod 444 <path to TLS CA certificate file>

        This sets the file permissions on the TLS CA file to                444
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.10', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.11":
    title: '3.11 | Ensure that Docker server certificate file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Docker server certificate file the file that is passed along with the            tlscert
         parameter is individual owned and group owned by            root
        .
    remediation: |
        You should run the following command: chown root:root <path to Docker server certificate file>

        This sets the individual ownership and the group ownership for the Docker server certificate file to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.11', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.12":
    title: '3.12 | Ensure that the Docker server certificate file permissions are set to 444 or more restrictively - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Docker server certificate file the file that is passed along with the            tlscert
         parameter has permissions of            444
         or more restrictive permissions.
    remediation: |
        You should execute the command below: chmod 444 <path to Docker server certificate file>

        This sets the file permissions of the Docker server certificate file to                444
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.12', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.13":
    title: '3.13 | Ensure that the Docker server certificate key file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Docker server certificate key file the file that is passed along with the            tlskey
         parameter is individually owned and group owned by            root
        .
    remediation: |
        You should execute the following command: chown root:root <path to Docker server certificate key file>

        This sets the individual ownership and group ownership for the Docker server certificate key file to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.13', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.14":
    title: '3.14 | Ensure that the Docker server certificate key file permissions are set to 400 - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Docker server certificate key file the file that is passed along with the            tlskey
         parameter has permissions of            400
        .
    remediation: |
        You should execute the following command: chmod 400 <path to Docker server certificate key file>

        This sets the Docker server certificate key file permissions to                400
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_3.14', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.15":
    title: '3.15 | Ensure that the Docker socket file ownership is set to rootdocker'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Docker socket file is owned by            root
         and group owned by            docker
        .
    remediation: |
        You should execute the following command: chown root:docker /var/run/docker.sock

        This sets the ownership to                root
         and group ownership to                docker
         for the default Docker socket file.             Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.15', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:
        - checks:
            - name: Undefined
              rule: 'Undefined'

  "3.16":
    title: '3.16 | Ensure that the Docker socket file permissions are set to 660 or more restrictively'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Docker socket file has permissions of            660
         or are configured more restrictively.
    remediation: |
        You should execute the command below. chmod 660 /var/run/docker.sock

        This sets the file permissions of the Docker socket file to                660
        .             Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.16', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "3.17":
    title: '3.17 | Ensure that the daemon.json file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            daemon.json
         file individual ownership and group ownership is correctly set to            root
        , if it is in use.
    remediation: |
        If the daemon.json file is present, you should execute the command below: chown root:root /etc/docker/daemon.json

        This sets the ownership and group ownership for the file to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_3.17', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.18":
    title: '3.18 | Ensure that daemon.json file permissions are set to 644 or more restrictive - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that if the            daemon.json
         is present its file permissions are correctly set to            644
         or more restrictively.
    remediation: |
        If the file is present, you should execute the command below: chmod 644 /etc/docker/daemon.json

        This sets the file permissions for this file to                644
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_3.18', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.19":
    title: '3.19 | Ensure that the etcdefaultdocker file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            /etc/default/docker
         file ownership and groupownership is correctly set to            root
        .
    remediation: |
        You should execute the following command chown root:root /etc/default/docker

        This sets the ownership and group ownership of the file to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_3.19', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.20":
    title: '3.20 | Ensure that the etcdefaultdocker file permissions are set to 644 or more restrictively - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            /etc/default/docker
         file permissions are correctly set to            644
         or more restrictively.
    remediation: |
        You should execute the following command: chmod 644 /etc/default/docker

        This sets the file permissions for this file to                644
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_3.20', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.21":
    title: '3.21 | Ensure that the etcsysconfigdocker file permissions are set to 644 or more restrictively - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            /etc/sysconfig/docker
         file permissions are correctly set to            644
         or more restrictively.
    remediation: |
        You should execute the following command: chmod 644 /etc/sysconfig/docker

        This sets the file permissions for this file to                644
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_3.21', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.22":
    title: '3.22 | Ensure that the etcsysconfigdocker file ownership is set to rootroot - manual'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the            /etc/sysconfig/docker
         file individual ownership and group ownership is correctly set to            root
        .
    remediation: |
        You should execute the following command: chown root:root /etc/sysconfig/docker

        This sets the ownership and group ownership for the file to                root
        .             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_3.22', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "3.23":
    title: '3.23 | Ensure that the Containerd socket file ownership is set to rootroot'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Containerd socket file is owned by            root
         and group owned by            root
        .
    remediation: |
        You should execute the following command: chown root:root /run/containerd/containerd.sock

        This sets the ownership to                root
         and group ownership to                root
         for the default Containerd socket file.             Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.23', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "3.24":
    title: '3.24 | Ensure that the Containerd socket file permissions are set to 660 or more restrictively'
    section: 'Docker daemon configuration files'
    description: |
        You should verify that the Containerd socket file has permissions of            660
         or are configured more restrictively.
    remediation: |
        You should execute the command below. chmod 660 /run/containerd/containerd.sock

        This sets the file permissions of the Containerd socket file to                660
        .             Impact: None.
    type: Undefined
    impact: '1.0'
    tags: ['level1', 'rule_3.24', 'cis_docker_benchmark']
    enabled: true
    properties:
      match: all
      rules:

  "4.1":
    title: '4.1 | Ensure that a user for the container has been created - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Containers should run as a nonroot user.
    remediation: |
        You should ensure that the Dockerfile for each container image contains the information below: USER <username or ID>

        In this case, the user name or ID refers to the user that was found in the container base image. If there is no specific
        user created in the container base image, then make use of the                useradd
         command to add a specific user before the                USER
         instruction in the Dockerfile.             For example, add the below lines in the Dockerfile to create a user in the
        container:
        RUN useradd -d /home/username -m -s /bin/bash username
        USER username
                     Note: If there are users in the image that are not needed,  you should consider deleting them. After
        deleting those users, commit the image and then generate new instances of the containers.
        Alternatively, if it is not possible to set the                USER
         directive in the Dockerfile, a script running as part of the                CMD
         or                ENTRYPOINT
         sections of the Dockerfile should be used to ensure that the container process switches to a non-root user.
        Impact: Running as a non-root user can present challenges where you wish to bind mount volumes from the underlying host.
        In this case, care should be taken to ensure that the user running the contained process can read and write to the bound
        directory, according to their requirements.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.2":
    title: '4.2 | Ensure that containers use only trusted base images - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        You should ensure that container images you use are either written from scratch or are based on another established and
        trusted base image downloaded over a secure channel.
    remediation: |
        The following procedures are useful for establishing trust for a specific image. Configure and use Docker Content trust.
        View the history of each Docker image to evaluate its risk, dependent on the sensitivity of the application   you wish
        to deploy using it. Scan Docker images for vulnerabilities at regular intervals. Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.3":
    title: '4.3 | Ensure that unnecessary packages are not installed in the container - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Containers should have as small a footprint as possible, and should not contain unnecessary software packages which
        could increase their attack surface.
    remediation: |
        You should not install anything within the container that is not required. You should consider using a minimal base
        image rather than the standard Centos, Debian, or Red Hat images if you can. Some of the options available include
        BusyBox and Alpine. Not only can this trim your image size considerably, but there would also be fewer pieces of
        software which could contain vectors for attack. Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.3', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.4":
    title: '4.4 | Ensure images are scanned and rebuilt to include security patches - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Images should be scanned frequently for any vulnerabilities. You should rebuild all images to include these patches and
        then instantiate new containers from them.
    remediation: |
        Images should be re-built ensuring that the latest version of the base images are used, to keep the operating system
        patch level at an appropriate level. Once the images have been re-built, containers should be re-started making use of
        the updated images. Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.4', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.5":
    title: '4.5 | Ensure Content trust for Docker is Enabled - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Content trust is disabled by default and should be enabled in line with organizational security policy.
    remediation: |
        To enable content trust in a bash shell, you should enter the following command: export DOCKER_CONTENT_TRUST=1
         Alternatively, you could set this environment variable in your profile file so that content trust in enabled on every
        login. Impact:
        In an environment where                  DOCKER_CONTENT_TRUST
         is set, you are required to follow trust procedures whilst working with the image related commands -
        build
        ,                  create
        ,                  pull
        ,                  push
        and                  run
        . You can use the                  --disable-content-trust
         flag to run individual operations on tagged images without content trust on an as needed basis, but this defeats the
        purpose of enabling content trust and therefore should be avoided wherever possible.               Note: Content trust
        is currently only available for users of the public Docker Hub. It is currently not available for the Docker Trusted
        Registry or for private registries.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_4.5', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.6":
    title: '4.6 | Ensure that HEALTHCHECK instructions have been added to container images - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        You should add the            HEALTHCHECK
         instruction to your Docker container images in order to ensure that health checks are executed against running
        containers.
    remediation: |
        You should follow the Docker documentation and rebuild your container images to include the                HEALTHCHECK
         instruction.             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.6', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.7":
    title: '4.7 | Ensure update instructions are not used alone in Dockerfiles - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        You should not use OS package manager update instructions such as            aptget update
         or            yum update
         either alone or in a single line in any Dockerfiles used to generate images under review.
    remediation: |
        You should use update instructions together with install instructions and version pinning for packages while installing
        them. This will prevent caching and force the extraction of the required versions.
        Alternatively, you could use the                --no-cache
         flag during the                docker build
         process to avoid using cached layers.             Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.7', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.8":
    title: '4.8 | Ensure setuid and setgid permissions are removed - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Removing setuid and setgid permissions in the images can prevent privilege escalation attacks within containers.
    remediation: |
        You should allow setuid and setgid permissions only on executables which require them. You could remove these
        permissions at build time by adding the following command in your Dockerfile, preferably towards the end of the
        Dockerfile: RUN find / -perm /6000 -type f -exec chmod a-s {} \; || true
         Impact: The above command would break all executables that depend on setuid or setgid permissions including legitimate
        ones. You should therefore be careful to modify the command to suit your requirements so that it does not reduce the
        permissions of legitimate programs excessively. Because of this, you should exercise a degree of caution and examine all
        processes carefully before making this type of modification in order to avoid outages.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_4.8', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.9":
    title: '4.9 | Ensure that COPY is used instead of ADD in Dockerfiles - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        You should use the            COPY
         instruction instead of the            ADD
         instruction in the Dockerfile.
    remediation: |
        You should use                COPY
         rather than                ADD
         instructions in Dockerfiles.             Impact:
        Care needs to be taken in implementing this control if the application requires functionality that is part of the
        ADD
         instruction, for example, if you need to retrieve files from remote URLs.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.9', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.10":
    title: '4.10 | Ensure secrets are not stored in Dockerfiles - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Do not store any secrets in Dockerfiles.
    remediation: |
        Do not store any kind of secrets within Dockerfiles. Where secrets are required during the build process, make use of a
        secrets management tool, such as the buildkit builder included with Docker. Impact: A proper secrets management process
        will be required for Docker image building.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.10', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.11":
    title: '4.11 | Ensure only verified packages are installed - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        You should verify the authenticity of packages before installing them into images.
    remediation: |
        You should use a secure package distribution mechanism of your choice to ensure the authenticity of software packages.
        Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_4.11', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "4.12":
    title: '4.12 | Ensure all signed artifacts are validated - manual'
    section: 'Container Images and Build File Configuration'
    description: |
        Validate artifacts signatures before uploading to the package registry.
    remediation: |
        Validate every artifact with its signature. It is recommended to do so automatically.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_4.12', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.1":
    title: '5.1 | Ensure swarm mode is not Enabled if not needed - manual'
    section: 'Container Runtime Configuration'
    description: |
        Do not enable swarm mode on a Docker engine instance unless this is needed.
    remediation: |
        If swarm mode has been enabled on a system in error, you should run the command below: docker swarm leave
         Impact: Disabling swarm mode will impact the operation of Docker Enterprise components if these are in use.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.2":
    title: '5.2 | Ensure that if applicable an AppArmor Profile is enabled - manual'
    section: 'Container Runtime Configuration'
    description: |
        AppArmor is an effective and easytouse Linux application security system. It is available on some Linux distributions by
        default, for example, on Debian and Ubuntu.
    remediation: |
        If AppArmor is applicable for your Linux OS, you should enable it. Verify AppArmor is installed. Create or import a
        AppArmor profile for Docker containers. Enable enforcement of the policy. Start your Docker container using the
        customized AppArmor profile. For example: docker run --interactive --tty --security-opt="apparmor:PROFILENAME" ubuntu
        /bin/bash
         Alternatively, Docker's default AppArmor policy can be used. Impact: The container will have the security controls
        defined in the AppArmor profile. It should be noted that if the AppArmor profile is misconfigured, this may cause issues
        with the operation of the container.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.3":
    title: '5.3 | Ensure that if applicable SELinux security options are set - manual'
    section: 'Container Runtime Configuration'
    description: |
        SELinux is an effective and easytouse Linux application security system. It is available by default on some
        distributions such as Red Hat and Fedora.
    remediation: |
        If SELinux is applicable for your Linux OS, you should use it. Set the SELinux State. Set the SELinux Policy. Create or
        import a SELinux policy template for Docker containers. Start Docker in daemon mode with SELinux enabled. For example:
        docker daemon --selinux-enabled

        or by adding the following to the                daemon.json
         configuration file:
        {
          "selinux-enabled": true
        }
                     Start your Docker container using the security options. For example, docker run --interactive --tty
        --security-opt label=level:TopSecret centos /bin/bash
         Impact: Any restrictions defined in the SELinux policy will be applied to your containers. It should be noted that if
        your SELinux policy is misconfigured, this may have an impact on the correct operation of the affected containers.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_5.3', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.4":
    title: '5.4 | Ensure that Linux kernel capabilities are restricted within containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        By default, Docker starts containers with a restricted set of Linux kernel capabilities. This means that any process can
        be granted the required capabilities instead of giving it root access. Using Linux kernel capabilities, processes in
        general do not need to run as the root user.
    remediation: |
        You should execute the command below to add required capabilities: docker run --cap-add={"Capability 1","Capability 2"}
        <Run arguments> <Container Image Name or ID> <Command>
         You should execute the command below to remove unneeded capabilities: docker run --cap-drop={"Capability 1","Capability
        2"} <Run arguments> <Container Image Name or ID> <Command>
         Alternatively, you could remove all the currently configured capabilities and then restore only the ones you
        specifically use: docker run --cap-drop=all --cap-add={"Capability 1","Capability 2"} <Run arguments> <Container Image
        Name or ID> <Command>

        Note that some settings also can be configured using the                --sysctl
         option, reducing the need for container capabilities even further. This includes unprivileged ICMP echo sockets without
        NET_RAW
         and allow opening any port less than 1024 without                NET_BIND_SERVICE
        .
        Adding and removing capabilities are also possible when the                docker service
         command is used:             docker service create --cap-drop=all --cap-add={"Capability 1","Capability 2"} <Run
        arguments> <Container Image Name or ID> <Command>
         Impact: Restrictions on processes within a container are based on which Linux capabilities are in force.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.4', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.5":
    title: '5.5 | Ensure that privileged containers are not used - manual'
    section: 'Container Runtime Configuration'
    description: |
        Using the            privileged
         flag provides all Linux kernel capabilities to the container to which it is applied and therefore overwrites the
        capadd
         and            capdrop
         flags. For this reason you should ensure that it is not used.
    remediation: |
        You should not run containers with the                --privileged
         flag.             For example, do not start a container using the command below: docker run --interactive --tty
        --privileged centos /bin/bash
         Impact:
        If you start a container without the                  --privileged
         flag, it will not have excessive default capabilities.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.5', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.6":
    title: '5.6 | Ensure sensitive host system directories are not mounted on containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should not allow sensitive host system directories such as those listed below to be mounted as container volumes,
        especially in readwrite mode.
        /
        /boot
        /dev
        /etc
        /lib
        /lib64
        /proc
        /sys
        /usr
    remediation: |
        You should not mount directories which are security sensitive on the host within containers, especially in read-write
        mode. Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.6', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.7":
    title: '5.7 | Ensure sshd is not run within containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        The SSH daemon should not be running within the container. You should SSH into the Docker host, and use
        docker exec
         to enter a container.
    remediation: |
        Uninstall the SSH daemon from the container and use and use                docker exec
         to enter a container on the remote host.             docker exec --interactive --tty <CONTAINER ID> sh
         OR docker attach <CONTAINER ID>
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.7', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.8":
    title: '5.8 | Ensure privileged ports are not mapped within containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        The TCP/IP port numbers below            1024
        are considered privileged ports. Normal users and processes are not allowed to use them for various security reasons.
        Docker does, however allow a container port to be mapped to a privileged port.
    remediation: |
        You should not map container ports to privileged host ports when starting a container. You should also, ensure that
        there is no such container to host privileged port mapping declarations in the Dockerfile. Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.8', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.9":
    title: '5.9 | Ensure that only needed ports are open on the container - manual'
    section: 'Container Runtime Configuration'
    description: |
        The dockerfile for a container image defines the ports which are opened by default on a container instance. The list of
        ports are relevant to the application you are running within the container and should only be open if they are needed.
    remediation: |
        You should ensure that the Dockerfile for each container image only exposes needed ports. You can also completely ignore
        the list of ports defined in the Dockerfile by                NOT
         using                -P
         (UPPERCASE) or the                --publish-all
         flag when starting the container. Instead, use the                -p
         (lowercase) or                --publish
         flag to explicitly define the ports that you need for a particular container instance.             For example: docker
        run --interactive --tty --publish 5000 --publish 5001 --publish 5002 centos /bin/bash
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.9', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.10":
    title: '5.10 | Ensure that the hosts network namespace is not shared - manual'
    section: 'Container Runtime Configuration'
    description: |
        When the networking mode on a container is set to            nethost
        , the container is not placed inside a separate network stack. Effectively, applying this option instructs Docker to not
        containerize the containers networking. The consequence of this is that the container lives outside in the main Docker
        host and has full access to its network interfaces.
    remediation: |
        You should not pass the                --net=host
         option when starting any container.             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.10', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.11":
    title: '5.11 | Ensure that the memory usage for containers is limited - manual'
    section: 'Container Runtime Configuration'
    description: |
        By default, all containers on a Docker host share resources equally. By using the resource management capabilities of
        the Docker host, you can control the amount of memory that a container is able to use.
    remediation: |
        You should run the container with only as much memory as it requires by using the                --memory
         argument.             For example, you could run a container using the command below: docker run -d --memory 256m
        centos sleep 1000
         In the example above, the container is started with a memory limit of 256 MB. Verify the memory settings by using the
        command below: docker inspect --format='{{ .Id }}: Memory={{.HostConfig.Memory}}
        KernelMemory={{.HostConfig.KernelMemory}} Swap={{.HostConfig.MemorySwap}}' <CONTAINER ID>
         Impact: If correct memory limits are not set on each container, one process can expand its usage and cause other
        containers to run out of resources.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.11', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.12":
    title: '5.12 | Ensure that CPU priority is set appropriately on containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        By default, all containers on a Docker host share resources equally. By using the resource management capabilities of
        the Docker host you can control the host CPU resources that a container may consume.
    remediation: |
        You should manage the CPU runtime between your containers dependent on their priority within your organization. To do so
        start the container using the                --cpu-shares
         argument.             For example, you could run a container as below: docker run -d --cpu-shares 512 centos sleep 1000
         In the example above, the container is started with CPU shares of 50% of what other containers use. So if the other
        container has CPU shares of 80%, this container will have CPU shares of 40%.
        Every new container will have                1024
         shares of CPU by default. However, this value is shown as                0
         if you run the command mentioned in the audit section.
        If you set one container’s CPU shares to                512
         it will receive half of the CPU time compared to the other containers. So if you take                1024
         as 100% you can then derive the number that you should set for respective CPU shares. For example, use
        512
         if you want to set it to 50% and                256
         if you want to set it 25%.
        You can also view the current CPU shares in the file                /sys/fs/cgroup/cpu/docker/<CONTAINER ID>/cpu.shares
        .             Impact: If you do not correctly assign CPU thresholds, the container process may run out of resources and
        become unresponsive. If CPU resources on the host are not constrainted, CPU shares do not place any restrictions on
        individual resources.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.12', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.13":
    title: '5.13 | Ensure that the containers root filesystem is mounted as read only - manual'
    section: 'Container Runtime Configuration'
    description: |
        The containers root filesystem should be treated as a golden image by using Docker runs            readonly
         option. This prevents any writes to the containers root filesystem at container runtime and enforces the principle of
        immutable infrastructure.
    remediation: |
        You should add a                --read-only
         flag at a container's runtime to enforce the container's root filesystem being mounted as read only.             docker
        run <Run arguments> --read-only <Container Image Name or ID> <Command>

        Enabling the                --read-only
         option at a container's runtime should be used by administrators to force a container's executable processes to only
        write container data to explicit storage locations during its lifetime.             Examples of explicit storage
        locations during a container's runtime include, but are not limited to:
        Using the                  --tmpfs
         option to mount a temporary file system for non-persistent data writes.               docker run --interactive --tty
        --read-only --tmpfs "/run" --tmpfs "/tmp" centos /bin/bash

        Enabling Docker                  rw
         mounts at a container's runtime to persist container data directly on the Docker host filesystem.               docker
        run --interactive --tty --read-only -v /opt/app/data:/run/app/data:rw centos /bin/bash
         Utilizing the Docker shared-storage volume plugin for Docker data volume to persist container data. docker volume
        create -d convoy --opt o=size=20GB my-named-volume
         docker run --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash
         Transmitting container data outside of the Docker controlled area during the container's runtime for container data in
        order to ensure that it is persistent.  Examples include hosted databases, network file shares and APIs. Impact:
        Enabling                  --read-only
         at container runtime may break some container OS packages if a data writing strategy is not defined.               You
        should define what the container's data should and should not persist at runtime in order to decide which strategy to
        use. Example:
        Enable use                    --tmpfs
         for temporary file writes to                    /tmp
                                 Use Docker shared data volumes for persistent data writes
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.13', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.14":
    title: '5.14 | Ensure that incoming container traffic is bound to a specific host interface - manual'
    section: 'Container Runtime Configuration'
    description: |
        By default, Docker containers can make connections to the outside world, but the outside world cannot connect to
        containers and each outgoing connection will appear to originate from one of the host machines own IP addresses. You
        should only allow container services to be contacted through a specific external interface on the host machine.
    remediation: |
        You should bind the container port to a specific host interface on the desired host port. For example, docker run
        --detach --publish 10.2.3.4:49153:80 nginx

        In the example above, the container port                80
         is bound to the host port on                49153
         and would accept incoming connection only from the                10.2.3.4
         external interface.             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.14', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.15":
    title: '5.15 | Ensure that the on-failure container restart policy is set to 5 - manual'
    section: 'Container Runtime Configuration'
    description: |
        By using the            restart
         flag in the            docker run
         command you can specify a restart policy for how a container should or should not be restarted on exit. You should
        choose the            onfailure
         restart policy and limit the restart attempts to            5
        .
    remediation: |
        If you wish a container to be automatically restarted, a sample command is as below: docker run --detach --restart=on-
        failure:5 nginx
         Impact: If this option is set, a container will only attempt to restart itself 5 times.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.15', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.16":
    title: '5.16 | Ensure that the hosts process namespace is not shared - manual'
    section: 'Container Runtime Configuration'
    description: |
        The Process ID PID namespace isolates the process ID space, meaning that processes in different PID namespaces can have
        the same PID. This creates process level isolation between the containers and the host.
    remediation: |
        You should not start a container with the                --pid=host
         argument.             For example, do not start a container with the command below: docker run --interactive --tty
        --pid=host centos /bin/bash
         Impact:
        Container processes cannot see processes on the host system. In certain circumstances, you may want your container to
        share the host's process namespace. For example, you could build a container containing debugging tools such as
        strace
         or                  gdb
        , and want to use these tools when debugging processes on the host. If this is desired, then share specific host
        processes using the                  -p
         switch.               For example: docker run --pid=host rhel7 strace -p 1234
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.16', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.17":
    title: '5.17 | Ensure that the hosts IPC namespace is not shared - manual'
    section: 'Container Runtime Configuration'
    description: |
        IPC POSIX/SysV IPC namespace provides separation of named shared memory segments, semaphores and message queues. The IPC
        namespace on the host should therefore not be shared with containers and should remain isolated.
    remediation: |
        You should not start a container with the                --ipc=host
         argument. For example, do not start a container as below:             docker run --interactive --tty --ipc=host centos
        /bin/bash
         Impact: Shared memory segments are used in order to accelerate interprocess communications, commonly in high-
        performance applications. If this type of application is containerized into multiple containers, you might need to share
        the IPC namespace of the containers in order to achieve high performance. Under these circumstances, you should still
        only share container specific IPC namespaces and not the host IPC namespace. A container's IPC namespace can be shared
        with another container as shown below: docker run --interactive --tty --ipc=container:e3a7a1a97c58 centos /bin/bash
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.17', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.18":
    title: '5.18 | Ensure that host devices are not directly exposed to containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        Host devices can be directly exposed to containers at runtime. Do not directly expose host devices to containers,
        especially to containers that are not trusted.
    remediation: |
        You should not directly expose host devices to containers. If you do need to expose host devices to containers, you
        should use granular permissions as appropriate to your organization: For example, do not start a container using the
        command below: docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rwm --device=/dev/temp_sda:/dev/temp_sda:rwm
        centos bash
         You should only share the host device using appropriate permissions: docker run --interactive --tty
        --device=/dev/tty0:/dev/tty0:rw --device=/dev/temp_sda:/dev/temp_sda:r centos bash
         Impact: You would not be able to use host devices directly within containers.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.18', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.19":
    title: '5.19 | Ensure that the default ulimit is overwritten at runtime if needed - manual'
    section: 'Container Runtime Configuration'
    description: |
        The default ulimit is set at the Docker daemon level. However, if you need to, you may override the default ulimit
        setting during container runtime.
    remediation: |
        You should only override the default ulimit settings if needed in a specific case. For example, to override default
        ulimit settings start a container as below: docker run -ti -d --ulimit nofile=1024:1024 centos sleep 1000
         Impact: If ulimits are not set correctly, overutilization by individual containers could make the host system unusable.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.19', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.20":
    title: '5.20 | Ensure mount propagation mode is not set to shared - manual'
    section: 'Container Runtime Configuration'
    description: |
        Mount propagation mode allows mounting volumes in shared, slave or private mode on a container. Do not use shared mount
        propagation mode unless explicitly needed.
    remediation: |
        Do not mount volumes in shared mode propagation. For example, do not start a container as below: docker run <Run
        arguments> --volume=/hostPath:/containerPath:shared <Container Image Name or ID> <Command>
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.20', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.21":
    title: '5.21 | Ensure that the hosts UTS namespace is not shared - manual'
    section: 'Container Runtime Configuration'
    description: |
        UTS namespaces provide isolation between two system identifiers the hostname and the NIS domain name. It is used to set
        the hostname and the domain which are visible to running processes in that namespace. Processes running within
        containers do not typically require to know either the hostname or the domain name. The UTS namespace should therefore
        not be shared with the host.
    remediation: |
        You should not start a container with the                --uts=host
         argument.             For example, do not start a container using the command below: docker run --rm --interactive
        --tty --uts=host rhel7.2
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.21', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.22":
    title: '5.22 | Ensure the default seccomp profile is not Disabled - manual'
    section: 'Container Runtime Configuration'
    description: |
        Seccomp filtering provides a means for a process to specify a filter for incoming system calls. The default Docker
        seccomp profile works on a whitelist basis and allows for a large number of common system calls, whilst blocking all
        others.  This filtering should not be disabled unless it causes a problem with your container application usage.
    remediation: |
        By default, seccomp profiles are enabled. You do not need to do anything unless you want to modify and use a modified
        seccomp profile. Impact:
        With Docker 1.10 and greater, the default seccomp profile blocks syscalls, regardless of                  --cap-add
         passed to the container. You should create your own custom seccomp profile in such cases. You may also disable the
        default seccomp profile by passing                  --security-opt=seccomp:unconfined
         on                  docker run
        .
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.22', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.23":
    title: '5.23 | Ensure that  docker exec commands are not used with the privileged option - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should not use            docker exec
         with the            privileged
         option.
    remediation: |
        You should not use the                --privileged
         option in                docker exec
         commands.             Impact: If you need enhanced capabilities within a container, then run it with all the
        permissions it requires.  These  should be specified individually.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_5.23', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.24":
    title: '5.24 | Ensure that docker exec commands are not used with the userroot option - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should not use            docker exec
         with the            userroot
         option.
    remediation: |
        You should not use the                --user=root
         option in                docker exec
         commands.             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_5.24', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.25":
    title: '5.25 | Ensure that cgroup usage is confirmed - manual'
    section: 'Container Runtime Configuration'
    description: |
        It is possible to attach to a particular cgroup when a container is instantiated. Confirming cgroup usage would ensure
        that containers are running in defined cgroups.
    remediation: |
        You should not use the                --cgroup-parent
         option within the                docker run
         command unless strictly required.             Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.25', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.26":
    title: '5.26 | Ensure that  the container is restricted from acquiring additional privileges - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should restrict the container from acquiring additional privileges via suid or sgid bits.
    remediation: |
        You should start your container with the options below: docker run --rm -it --security-opt=no-new-privileges ubuntu bash
         Impact:
        The                  no_new_priv
         option prevents LSMs like SELinux from allowing processes to acquire new privileges
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.26', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.27":
    title: '5.27 | Ensure that container health is checked at runtime - manual'
    section: 'Container Runtime Configuration'
    description: |
        If the container image does not have an            HEALTHCHECK
         instruction defined, you should use the            healthcmd
         parameter at container runtime to check container health.
    remediation: |
        You should run the container using the                --health-cmd
         parameter.             For example: docker run -d --health-cmd='stat /etc/passwd || exit 1' nginx
         Impact: None.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.27', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.28":
    title: '5.28 | Ensure that Docker commands always make use of the latest version of their image - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should always ensure that you are using the latest version of the images within your repository and not cached older
        versions.
    remediation: |
        You should use proper version pinning mechanisms (the "latest" tag which is assigned by default is still vulnerable to
        caching attacks) to avoid extracting cached older versions. Version pinning mechanisms should be used for base images,
        packages, and entire images. You can customize version pinning rules according to your requirements. Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.28', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.29":
    title: '5.29 | Ensure that the PIDs cgroup limit is used - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should use the            pidslimit
         flag at container runtime.
    remediation: |
        Use                --pids-limit
         flag with an appropriate value when launching the container.             For example: docker run -it --pids-limit 100
        <Image ID>
         In the above example, the number of processes allowed to run at any given time is set to 100. After a limit of 100
        concurrently running processes is reached, Docker would restrict any new process creation. Impact: Set the PIDs limit
        value as appropriate. Incorrect values might leave containers unusable.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.29', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.30":
    title: '5.30 | Ensure that Dockers default bridge docker0 is not used - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should not use Dockers default bridge            docker0
        . Instead you should use Dockers userdefined networks for container networking.
    remediation: |
        You should follow the Docker documentation and set up a user-defined network. All the containers should be run in this
        network. Impact: User-defined networks need to be configured and managed in line with organizational security policy.
    type: Undefined
    impact: '0.0'
    tags: ['level2', 'rule_5.30', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.31":
    title: '5.31 | Ensure that the hosts user namespaces are not shared - manual'
    section: 'Container Runtime Configuration'
    description: |
        You should not share the hosts user namespaces with containers running on it.
    remediation: |
        You should not share user namespaces between host and containers. For example, you should not run the command below:
        docker run --rm -it --userns=host ubuntu bash
         Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.31', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "5.32":
    title: '5.32 | Ensure that the Docker socket is not mounted inside any containers - manual'
    section: 'Container Runtime Configuration'
    description: |
        The Docker socket            docker.sock
         should not be mounted inside a container.
    remediation: |
        You should ensure that no containers mount                docker.sock
         as a volume.             Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_5.32', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "6.1":
    title: '6.1 | Ensure that image sprawl is avoided - manual'
    section: 'Docker Security Operations'
    description: |
        You should not keep a large number of container images on the same host. Use only tagged images as appropriate.
    remediation: |
        You should keep only the images that you actually need and establish a workflow to remove old or stale images from the
        host. Additionally, you should use features such as pull-by-digest to get specific images from the registry. You can
        follow the steps below to find unused images on the system so they can be deleted. Step 1
         Make a list of all image IDs that are currently instantiated by executing the command below:             docker images
        --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'
         Step 2
        : List all the images present on the system by executing the command below:             docker images
         Step 3
        : Compare the list of image IDs created from Step 1 and Step 2 to find out images which are currently not being
        instantiated.             Step 4
        : Decide if you want to keep the images that are not currently in use. If they are not needed, delete them by executing
        the following command:             docker rmi <IMAGE ID>

        Alternatively, the                docker system prune
         command can be used to remove dangling images which are not tagged or, if necessary, all images that are not currently
        used by a running container when used with the                -a
         option.             Impact: docker system prune -a
         removes all exited containers as well as all images and volumes that are not referenced by running containers.
        If any images are removed, this would result in needing to reload the images to the host.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_6.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "6.2":
    title: '6.2 | Ensure that container sprawl is avoided - manual'
    section: 'Docker Security Operations'
    description: |
        You should not keep a large number of containers on the same host.
    remediation: |
        You should periodically check your container inventory on each host and clean up containers which are not in active use
        with the command below: docker container prune
         Impact: You should retain containers that are actively in use, and delete ones which are no longer needed.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_6.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.1":
    title: '7.1 | Ensure that the minimum number of manager nodes have been created in a swarm - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should ensure that the minimum number of required manager nodes is created in a swarm.
    remediation: |
        If an excessive number of managers is configured, the excess nodes can be demoted to workers using the following
        command: docker node demote <ID>
         Where <ID> is the node ID value of the manager to be demoted. Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.1', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.2":
    title: '7.2 | Ensure that swarm services are bound to a specific host interface - manual'
    section: 'Docker Swarm Configuration'
    description: |
        By default, Docker swarm services will listen on all interfaces on the host.  This may not be necessary for the
        operation of the swarm where the host has multiple network interfaces.
    remediation: |
        Resolving this issues requires re-initialization of the swarm, specifying a specific interface for the
        --listen-addr
         parameter.             Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.2', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.3":
    title: '7.3 | Ensure that all Docker swarm overlay networks are encrypted - manual'
    section: 'Docker Swarm Configuration'
    description: |
        Ensure that all Docker swarm overlay networks are encrypted.
    remediation: |
        You should create overlay networks the with                --opt encrypted
         flag.             Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.3', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.4":
    title: '7.4 | Ensure that Dockers secret management commands are used for managing secrets in a swarm cluster - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should use Dockers inbuilt secret management command for control of secrets.
    remediation: |
        You should follow the                docker secret
         documentation and use it to manage secrets effectively.             Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.4', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.5":
    title: '7.5 | Ensure that swarm manager is run in auto-lock mode - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should review whether you wish to run Docker swarm manager in autolock mode.
    remediation: |
        If you are initializing a swarm, use the command below. docker swarm init --autolock

        If you want to set                --autolock
         on an existing swarm manager node, use the following command.             docker swarm update --autolock
         Impact: A swarm in auto-lock mode will not recover from a restart without manual intervention from an administrator to
        enter the unlock key.  This may not always be desirable, and should be reviewed at a policy level.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.5', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.6":
    title: '7.6 | Ensure that the swarm manager auto-lock key is rotated periodically - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should rotate the swarm manager autolock key periodically.
    remediation: |
        You should run the command below to rotate the keys. docker swarm unlock-key --rotate
         Additionally, to facilitate auditing of this recommendation, you should maintain key rotation records and ensure that
        you establish a pre-defined frequency for key rotation. Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.6', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.7":
    title: '7.7 | Ensure that node certificates are rotated as appropriate - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should rotate swarm node certificates in line with your organizational security policy.
    remediation: |
        You should run the command to set the desired expiry time on the node certificate. For example: docker swarm update
        --cert-expiry 48h
         Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.7', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.8":
    title: '7.8 | Ensure that CA certificates are rotated as appropriate - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should rotate root CA certificates as appropriate.
    remediation: |
        You should run the command below to rotate a certificate. docker swarm ca --rotate
         Impact: None
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.8', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:

  "7.9":
    title: '7.9 | Ensure that management plane traffic is separated from data plane traffic - manual'
    section: 'Docker Swarm Configuration'
    description: |
        You should separate management plane traffic from data plane traffic.
    remediation: |
        You should initialize the swarm with dedicated interfaces for management and data planes respectively. For example,
        docker swarm init --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3
         Impact: This requires two network interfaces per node.
    type: Undefined
    impact: '0.0'
    tags: ['level1', 'rule_7.9', 'cis_docker_benchmark']
    enabled: false
    properties:
      match: all
      rules:
